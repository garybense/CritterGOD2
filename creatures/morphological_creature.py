"""
Morphological creature with evolved 3D body.

Extends EnhancedCreature with:
- Procedurally generated 3D body from genotype
- Body-based physics and energy costs
- Morphological evolution
- Drug-responsive body appearance

This is the complete creature: brain + body + senses + motors + drugs + energy.
"""

from typing import Optional
import numpy as np
from creatures.enhanced_creature import EnhancedCreature
from core.morphology.body_genotype import BodyGenotype
from core.morphology.mesh_generator import Mesh3D
from core.evolution.genotype import Genotype
from core.morphic.circuit8 import Circuit8


class MorphologicalCreature(EnhancedCreature):
    """
    Complete creature with evolved 3D body morphology.
    
    Combines:
    - Neural network (brain)
    - 3D body (procedural mesh from genetics)
    - Sensory systems (vision, proprioception)
    - Motor systems (audio, text, visual)
    - Psychopharmacology (drug effects on brain and body)
    - Energy metabolism (costs based on body mass)
    
    Attributes:
        body: 3D body genotype
        mesh: Generated 3D mesh (cached, generated on demand)
        body_mass: Total body mass for physics/energy
    """
    
    def __init__(
        self,
        genotype: Genotype,
        body: Optional[BodyGenotype] = None,
        x: float = 0.0,
        y: float = 0.0,
        z: float = 0.0,
        initial_energy: float = 1000000.0,
        circuit8: Optional[Circuit8] = None,
        **kwargs
    ):
        """
        Create morphological creature with 3D body.
        
        Args:
            genotype: Neural network genotype (brain)
            body: Body genotype (3D morphology), random if None
            x, y, z: Initial position
            initial_energy: Starting energy
            circuit8: Shared telepathic canvas
            **kwargs: Additional arguments for EnhancedCreature
        """
        # Initialize base enhanced creature
        super().__init__(
            genotype=genotype,
            x=x,
            y=y,
            initial_energy=initial_energy,
            circuit8=circuit8,
            **kwargs
        )
        
        # Initialize or generate body
        if body is None:
            self.body = BodyGenotype.create_random(min_segments=2, max_segments=5)
        else:
            self.body = body
        
        # 3D position
        self.z = z
        
        # Calculate body mass
        self.body_mass = self.body.get_total_mass()
        
        # Mesh will be generated by renderer on demand
        self.mesh: Optional[Mesh3D] = None
        
        # Movement velocities (for future physics)
        self.vx = 0.0
        self.vy = 0.0
        self.vz = 0.0
        
        # Body animation state (for future)
        self.body_phase = 0.0  # Animation phase (0-1)
        self.body_pulse = 1.0  # Size pulsing factor (0.8-1.2)
    
    def update(self, dt: float = 1.0) -> bool:
        """
        Update creature with body-aware energy costs.
        
        Energy costs scale with body mass:
        - Larger bodies cost more to maintain
        - More limbs increase metabolic cost
        
        Args:
            dt: Time step
            
        Returns:
            True if alive, False if dead
        """
        # Run enhanced creature update (brain, senses, motors, drugs)
        alive = super().update(dt)
        if not alive:
            return False
        
        # Additional body maintenance cost
        body_cost = self.body_mass * 0.01 * dt
        self.energy.spend_energy(body_cost)
        
        # Update body animation state (for drug effects)
        self.body_phase = (self.body_phase + dt * 0.1) % 1.0
        
        # Body pulsing based on drug levels
        trip_intensity = np.sum(self.drugs.tripping)
        if trip_intensity > 0.1:
            # Psychedelic pulsing
            pulse_speed = 0.5 + trip_intensity * 2.0
            pulse_amount = 0.1 + trip_intensity * 0.2
            self.body_pulse = 1.0 + np.sin(self.body_phase * pulse_speed * 2 * np.pi) * pulse_amount
        else:
            # Return to normal size
            self.body_pulse = 1.0
        
        # Check survival (energy-based)
        if self.energy.energy <= 0:
            return False
        
        return True
    
    def mutate_body(self, mutation_rate: float = 0.1) -> 'MorphologicalCreature':
        """
        Create offspring with mutated body.
        
        Args:
            mutation_rate: Body mutation probability
            
        Returns:
            New creature with mutated body and brain
        """
        # Mutate brain (existing genotype mutation)
        new_brain_genotype = self.genotype.mutate(mutation_rate)
        
        # Mutate body
        new_body = self.body.mutate(mutation_rate)
        
        # Inherit language (genetic text)
        seed_text = None
        if hasattr(self, 'motors') and hasattr(self.motors, 'markov'):
            # Get sample of parent's language
            seed_text = self.motors.markov.generate_and_evolve(max_length=20)
        
        # Create offspring
        offspring = MorphologicalCreature(
            genotype=new_brain_genotype,
            body=new_body,
            x=self.x + np.random.uniform(-5, 5),
            y=self.y + np.random.uniform(-5, 5),
            z=self.z,
            initial_energy=self.energy.energy * 0.5,  # Split energy
            circuit8=self.circuit8,
            seed_text=seed_text
        )
        
        # Inherit parent's generation + 1
        offspring.generation = self.generation + 1
        offspring.adam_distance = self.adam_distance + 1
        
        return offspring
    
    def get_body_color_with_drugs(self) -> tuple[float, float, float]:
        """
        Get body color modified by drug effects.
        
        Returns:
            RGB color tuple (0-1)
        """
        base_hue = self.body.base_hue
        
        # Drug effects on color
        trip_level = np.sum(self.drugs.tripping)
        
        if trip_level > 0.1:
            # Psychedelic hue shift
            hue_shift = np.sin(self.body_phase * 5 * np.pi) * 60 * trip_level
            hue = (base_hue + hue_shift) % 360
            
            # Increased saturation/brightness while tripping
            saturation = 0.7 + trip_level * 0.3
            value = 0.8 + trip_level * 0.2
        else:
            hue = base_hue
            saturation = 0.7
            value = 0.8
        
        # Convert HSV to RGB
        return self._hsv_to_rgb(hue, saturation, value)
    
    def _hsv_to_rgb(self, h: float, s: float, v: float) -> tuple[float, float, float]:
        """Convert HSV to RGB."""
        h = (h % 360) / 60.0
        c = v * s
        x = c * (1 - abs(h % 2 - 1))
        m = v - c
        
        if h < 1:
            r, g, b = c, x, 0
        elif h < 2:
            r, g, b = x, c, 0
        elif h < 3:
            r, g, b = 0, c, x
        elif h < 4:
            r, g, b = 0, x, c
        elif h < 5:
            r, g, b = x, 0, c
        else:
            r, g, b = c, 0, x
        
        return (r + m, g + m, b + m)
    
    def get_render_scale(self) -> float:
        """
        Get current body render scale (for pulsing).
        
        Returns:
            Scale factor (typically 0.8-1.2)
        """
        return self.body_pulse
    
    def to_dict(self) -> dict:
        """
        Export creature state for debugging/introspection.
        
        Returns:
            Complete creature state dictionary
        """
        base_dict = super().to_dict()
        
        # Add body information
        base_dict.update({
            'body': {
                'segments': len(self.body.segments),
                'head_size': self.body.head_size,
                'tail_length': self.body.tail_length,
                'symmetry': self.body.symmetry,
                'base_hue': self.body.base_hue,
                'mass': self.body_mass,
                'pattern_type': self.body.pattern_type,
                'metallic': self.body.metallic
            },
            'position_3d': {
                'x': self.x,
                'y': self.y,
                'z': self.z
            },
            'velocity_3d': {
                'vx': self.vx,
                'vy': self.vy,
                'vz': self.vz
            },
            'body_animation': {
                'phase': self.body_phase,
                'pulse': self.body_pulse
            }
        })
        
        return base_dict
